# -*- coding: utf-8 -*-
"""Jogo da Velha - Oficial

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1qCXdTyaoTL6oyA-LEacHx6c-UuTMh5MH
"""

pip install tensorflow

# Importação de bibliotecas e módulos necessários
import random
import numpy as np
import pickle
import tensorflow
import math
import time
import keras
import pandas
import matplotlib
import scipy
from typing import List, Optional


# Definição da classe Board (tabuleiro)
class Board:
    def __init__(self):
        self.board = [' '] * 9
        self.current_player = 'X'

    def print_board(self):
        # Imprimindo o estado atual do tabuleiro
        print(f" {self.board[0]} | {self.board[1]} | {self.board[2]} ")
        print("---+---+---")
        print(f" {self.board[3]} | {self.board[4]} | {self.board[5]} ")
        print("---+---+---")
        print(f" {self.board[6]} | {self.board[7]} | {self.board[8]} ")

    def make_move(self, position):
        # Fazendo um movimento no tabuleiro
        if position < 1 or position > 9 or self.board[position - 1] != ' ':
            return False

        self.board[position - 1] = self.current_player
        self.current_player = 'O' if self.current_player == 'X' else 'X'
        return True

    def is_winner(self, player):
        # Verificar se houve vencedor
        return (
            (self.board[0] == player and self.board[1] == player and self.board[2] == player) or
            (self.board[3] == player and self.board[4] == player and self.board[5] == player) or
            (self.board[6] == player and self.board[7] == player and self.board[8] == player) or
            (self.board[0] == player and self.board[3] == player and self.board[6] == player) or
            (self.board[1] == player and self.board[4] == player and self.board[7] == player) or
            (self.board[2] == player and self.board[5] == player and self.board[8] == player) or
            (self.board[0] == player and self.board[4] == player and self.board[8] == player) or
            (self.board[2] == player and self.board[4] == player and self.board[6] == player)
        )

    def is_full(self):
        # Verificando se o tabuleiro está cheia
        return ' ' not in self.board

    def get_empty_squares(self):
        # Obtendo uma lista de quadrados vazios no quadro
        return [i + 1 for i in range(9) if self.board[i] == ' ']

# Definindo a classe Node para a árvore do jogo
class Node:
    def __init__(self, board, player):
        self.board = board
        self.player = player
        self.children = []
        self.alpha = float('-inf')
        self.beta = float('inf')
        self.score = None

    def is_terminal_node(self):
        # Verificando se o nó é um nó terminal
        return self.board.is_winner('X') or self.board.is_winner('O') or len(self.board.get_empty_squares()) == 0

    def get_best_move(self):
        # Obtendo o melhor movimento dos nós filhos
        best_score = float('-inf')
        best_moves = []
        for child in self.children:
            if child.score == best_score:
                best_moves.append(child.board.last_move)
            elif child.score > best_score:
                best_score = child.score
                best_moves = [child.board.last_move]
        return random.choice(best_moves) if best_moves else random.choice(self.board.get_empty_squares())

# Definindo a classe AlphaBeta para o algoritmo minimax
class AlphaBeta:
    def __init__(self, depth):
        self.depth = depth

    def minimax(self, node, depth, maximizing_player):
        if depth == 0 or node.is_terminal_node():
            return node.board.get_score('O'), node

        if maximizing_player:
            max_node = node
            max_score = float('-inf')
            for child in node.children:
                score, _ = self.minimax(child, depth - 1, False)
                if score > max_score:
                    max_score = score
                    max_node = child
                node.alpha = max(node.alpha, max_score)
                if node.alpha >= node.beta:
                    break
            return max_score, max_node
        else:
            min_node = node
            min_score = float('inf')
            for child in node.children:
                score, _ = self.minimax(child, depth - 1, True)
                if score < min_score:
                    min_score = score
                    min_node = child
                node.beta = min(node.beta, min_score)
                if node.beta <= node.alpha:
                    break
            return min_score, min_node

# Definindo a classe jogo da velha para para começar o jogo
class JogoDaVelha:
    def __init__(self):
        self.board = Board()
        self.first_player = random.choice(['X', 'O'])
        self.board.current_player = self.first_player

    def play_human_vs_computer(self):
        # Jogando humano vs. computador
        print("Bem-vindo ao Jogo da Velha! Você está jogando contra o computador.")

        # Determinar aleatoriamente o primeiro jogador
        first_player = random.choice(['X', 'O'])
        self.board.current_player = first_player

        while True:
            self.board.print_board()

            if self.board.is_winner('X'):
                print("Você ganhou!")
                break
            elif self.board.is_winner('O'):
                print("Computer ganhou!")
                break
            elif self.board.is_full():
                print("Deu velha!")
                break

            if self.board.current_player == 'X':
                while True:
                    position = input("digite uma opção entre (1-9): ")
                    if position.isdigit():
                        position = int(position)
                        if self.board.make_move(position):
                            break
                    print("Movimento inválido. Tente novamente.")
            else:
                empty_squares = self.board.get_empty_squares()
                position = random.choice(empty_squares)
                self.board.make_move(position)
                print(f"Computador jogou: {position}")

    def play_human_vs_human(self):
        # Jogando Humano vs. Humano
        print("Bem-vindo ao Jogo da Velha! O Jogador 1 é X e o Jogador 2 é O.")

        while True:
            self.board.print_board()

            if self.board.is_winner('X'):
                print("Jogador 1 ganhou!")
                break
            elif self.board.is_winner('O'):
                print("Jogador 2 ganhou!")
                break
            elif self.board.is_full():
                print("Deu velha!")
                break

            while True:
                player = "Jogador 1" if self.board.current_player == 'X' else "Jogador 2"
                position = input(f"{player}, digite uma opção entre (1-9): ")
                if position.isdigit():
                    position = int(position)
                    if self.board.make_move(position):
                        break
                print("Movimento inválido. Tente novamente.")

    def play_computer_vs_computer(self):
        # Jogando computador vs. computador
        print("Bem-vindo ao Jogo da Velha! O computador 1 é X e o computador 2 é O.")

        while True:
            self.board.print_board()

            if self.board.is_winner('X'):
                print("Computer 1 ganhou!")
                break
            elif self.board.is_winner('O'):
                print("Computer 2 ganhou!")
                break
            elif self.board.is_full():
                print("Deu velha!")
                break

            if self.board.current_player == 'X':
                empty_squares = self.board.get_empty_squares()
                position = random.choice(empty_squares)
                self.board.make_move(position)
                print(f"Computador 1 jogou: {position}")
            else:
                empty_squares = self.board.get_empty_squares()
                position = random.choice(empty_squares)
                self.board.make_move(position)
                print(f"Computador 2 jogou: {position}")

    def start_game(self):
          # Iniciando o jogo e selecionando o modo de jogo
          print("Bem-vindo ao Jogo da Velha!")
          print("Escolha um modo de jogo:")
          print("1. Humano x Computador")
          print("2. Humano x Humano")
          print("3. Computador x Computador")

          while True:
              choice = input("Digite sua escolha (1-3): ")
              if choice in ['1', '2', '3']:
                  break
              print("Escolha inválida. Tente novamente.")

          if choice == '1':
              self.play_human_vs_computer()
          elif choice == '2':
              self.play_human_vs_human()
          else:
              self.play_computer_vs_computer()

          while True:
              play_again = input("Quer jogar de novo? (s/n): ")
              if play_again.lower() == "s":
                  self.board = Board()  # Redefinir o tabuleiro
                  self.start_game()  # Começa um novo jogo
                  break
              elif play_again.lower() == "n":
                  print("Obrigado por jogar o Jogo da Velha. Até logo!")
                  break
              else:
                  print("Escolha inválida. Por favor, digite 'sim' ou 'não'.")

# Cria uma instância da classe jogo da velha e inicia o jogo
game = JogoDaVelha()
game.start_game()

